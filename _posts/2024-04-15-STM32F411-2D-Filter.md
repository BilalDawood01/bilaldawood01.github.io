---
date: 2024-04-15 12:26:40
layout: post
title: STM32F411 Microcontroller 2D Image Filter 
subtitle: Optimizations and filters on the ARM Cortex M4 Processor
description: Implementation of various FIR and IIR filters on the ARM Cortex M4 processor through the use of ARM Assembly and C Code. 
image: 
optimized_image: "/assets/img/uploads/img_conv.png"
category: Embedded Designing
tags:
  - Team Project
  - Software Design 
  - Micrcontroller
  - Python
  - Embedded designing
  - Optimization
  - Report Writing
  - ARM Assembly 
  - C code
  - Assembly Analysis
author: Bilal Dawood
paginate: true
---
<!-- - [Project Overview](#project-overview)

- [Initial Implementation](#1-initial-implementation)
  - [Overview](#overview-1)
  - [Key Challenges](#key-challenges-1)

- [Performance Profiling](#2-performance-profiling)
  - [Overview](#overview-2)
  - [Key Insights](#key-insights-2)
  - [Results](#results-2)

- [Optimized Implementation](#3-optimized-implementation)
  - [Overview](#overview-3)
  - [Key Challenges](#key-challenges-3)
  - [Results](#results-3)

- [Assembly Code Analysis](#4-assembly-code-analysis)
  - [Overview](#overview-4)
  - [Key Insights](#key-insights-4)
  - [Results](#results-4)

- [Final Thoughts](#5-final-thoughts)
  - [Lessons Learned](#lessons-learned-5)
  - [Future Work](#future-work-5) -->



## Project Overview
This project involved implementing and optimizing a pixel processing algorithm on an STM32 microcontroller. The journey from a naive implementation to a highly optimized version involved deep dives into low-level programming, performance profiling, and assembly code analysis. Here’s a look at what was accomplished:
<div style="flex: 1; padding: 10px;">
  <img src="/assets/img/img_conv/named.png" alt="Filtered Images" style="width: 100%;">
  <figcaption style="text-align: center;">Result after applying various filters</figcaption>
</div>

### 1. Initial Implementation
#### Overview
In the initial phase, the implementation involved iterating over each subpixel (red, green, or blue) in the image buffer. A 3x3 kernel with 32-bit Q17.15 coefficients was applied to process the subpixels. The output was stored in the STM32F411VE’s internal memory, with special attention to handling image edges and preventing overflow.

<div style="display: flex; align-items: center; justify-content: space-between;">
  <div style="flex: 1; padding: 10px;">
    <img src="/assets/img/img_conv/STM32F411E-DISCO.png" alt="STM32F411-DISCO" style="width: 100%;">
    <figcaption style="text-align: center;">Our Microcontroller</figcaption>
  </div>
  <div style="flex: 1; padding: 10px;">
    <img src="/assets/img/img_conv/2D_Convolution_Animation.gif" alt="Image Convolution Illustration" style="width: 100%;">
    <figcaption style="text-align: center;">Detailed Illustration of Image Convolution</figcaption>
  </div>
</div>

#### Key Challenges
- Managing memory offsets and ensuring efficient access patterns.
- Handling image edges by copying edge values, which introduced overhead.
- Avoiding overflow in the 32-bit accumulator when dealing with Q25.15 numbers.

<div style="flex: 1; padding: 10px;">
  <img src="/assets/img/img_conv/Visual_representation.png" alt="Our Image Convolution Approach" style="width: 100%;">
  <figcaption style="text-align: center;">Our Image Convolution Approach</figcaption>
</div>

#### Results
The basic implementation processed each subpixel individually, resulting in a high loop count and suboptimal performance. Profiling revealed an average of 1810 cycles and 150 microseconds per subpixel, leading to an estimated total processing time of over 9 seconds for the entire image set.

<div style="flex: 1; padding: 10px;">
  <img src="/assets/img/img_conv/example.png" alt="Viewing Emboss filter Results" style="width: 100%;">
  <figcaption style="text-align: center;">Viewing and Verifying Our Results with our Python Notebook</figcaption>
</div>

### 2. Performance Profiling
#### Overview
Performance profiling was critical in identifying bottlenecks and areas for optimization. Using the ITM data trace, I tracked the cycle count and time taken for each subpixel update. This involved monitoring the multiply-accumulate-saturate code and assessing the accuracy of profiling methods.

#### Key Insights
- Inconsistent cycle counts and time measurements due to debugging or memory access issues.
- The initial profiling method indicated a longer processing time than observed in practice, leading to adjustments in the profiling approach.

#### Results
A more reliable profiling method estimated a processing time of approximately 1.117 seconds, aligning better with observed performance. The profiling highlighted the need for reducing the loop count and optimizing nested loops.

### 3. Optimized Implementation
#### Overview
The optimized implementation focused on reducing the number of iterations and leveraging SIMD instructions. Key optimizations included:
- Unrolling the loop to process red, green, and blue subpixels together, reducing the outer loop count by a factor of three.
- Using the CMSIS function interfacing with the SMLAD instruction for SIMD multiply-accumulate operations, reducing the innermost loop count by half.

#### Key Challenges
- Managing increased memory footprint due to additional buffers.
- Handling the odd length of kernels and pixel arrays by padding with zeros.
- Ensuring that the introduced complexity did not outweigh the benefits of reduced loop counts.

#### Results
The optimized implementation achieved a significant performance boost:
- Average cycles per pixel: 3138, with 295 microseconds per pixel.
- Total estimated processing time: 0.753 seconds, representing a 32.54% decrease compared to the initial implementation.
- A dramatic reduction in loop count from 1,352,005 to 368,965, over 72% less.

### 4. Assembly Code Analysis
#### Overview
Analyzing the assembly code was crucial for understanding the impact of optimizations at the instruction level. Despite an increase in the number of instructions due to packing and control logic, the overall performance improved.

#### Key Insights
- Basic ARM instructions dominated the initial implementation, while the optimized version included more complex packing instructions.
- Reducing loop counts had a significant impact on overall performance, despite the added complexity in the assembly code.

#### Results
The analysis confirmed that the optimized implementation, though more complex, effectively reduced the total number of executed instructions. This balance between reduced loop counts and increased instruction complexity led to the overall speedup.

### 5. Final Thoughts
#### Lessons Learned
- Effective performance optimization requires a balance between reducing loop counts and managing the complexity of added instructions.
- Profiling and assembly analysis are essential tools for identifying bottlenecks and validating optimizations.
- Understanding low-level operations and leveraging hardware-specific instructions can yield significant performance improvements.

#### Future Work
- Exploring further optimizations, such as additional loop unrolling or specialized hardware instructions.
- Investigating hardware-specific optimizations, like dedicated loop controllers or advanced SIMD instructions.

Thank you for reviewing my project! I look forward to discussing how my skills and experiences can contribute to your team.
