---
date: 2024-02-15 12:26:40
layout: post
title: Hardware Optimization techniques on PYNQ Z2 FPGA
subtitle: Implementations of hardware optimization methods on the FPGA
description: Implementation of various FIR and IIR filters on the ARM Cortex M4 processor through the use of ARM Assembly and C Code. 
image: "/assets/img/uploads/pynqz2.jpg"
optimized_image: "/assets/img/uploads/pynqz2_opt.jpg"
category: FPGA
tags:
  - Python
  - C code
  - ARM Assembly 
  - High-Level-Synthesis (HLS)
  - Xilinx 
  - Vivado
  - Fabrication
  - Bit level synthesis
  - Ethernet
  - FPGA
  - Optimization
  - Report Writing
author: Bilal Dawood
paginate: true
toc: True
---
<!--  
* [Outline](#outline)  
* [Summary of Tasks and Results](#summary-of-tasks-and-results)  
* [Skills and Technologies Used](#skills-and-technologies-used)  
* [General Overview of the Lab and Results](#general-overview-of-the-lab-and-results)   -->

#### OUTLINE
In this lab, we will continue exploring HLS to create a hardware accelerator, leveraging the Pynq-Z2 board and the Zynq 7020 chip (part xc7z020clg400-1). By the end of this lab, you should be able to:
- Write C/C++ code that can be synthesized by an HLS tool into hardware.
- Modify C/C++ code to introduce various optimization transformations for HLS.
- Take the hardware generated by Vitis HLS and feed it into Vivado, producing an overlay for the Pynq board.
- Power up, connect to, and load the overlay into the Pynq board, writing Python code to interface with the new hardware.
- Copy added files from the Pynq board to your computer and remove them from the board after completion.

### Summary of Tasks and Results

- We performed C synthesis and obtained the synthesis report.
- Completing the entire Vivado flow, we compared utilization estimates and noticed a mismatch between Vitis and Vivado.
- We modified the Jupyter notebook to print the first 10 entries of `out_actual`.
- Measuring the execution time of the FIR filter, we found the software version to be faster than the hardware version.
- Comparing `fir_fission` with `fir_orig`, we observed increased latency but reduced resource usage.
- Manual unrolling improved latency but resulted in increased resource usage.
- Further unrolling (factor of 3) significantly improved latency but also increased resource utilization.
- Using pragmas for full unrolling reduced resource utilization but increased latency compared to manual unrolling.
- Unrolling the TDL loop with a factor of 2 further reduced resource usage.
- Fully unrolling both loops dramatically increased resource utilization without improving latency.
- Varying the loop initiation interval (II) had minimal effect on latency but affected resource usage.
- The best implementation, involving unrolling the TDL and MAC loops with a factor of 2 and pipelining, showed a slight improvement in hardware performance but was still slower than the software implementation.
- We reflected on the importance of careful profiling and understanding the impact of various optimization techniques.

### Skills and Technologies Used

- **High-Level Synthesis (HLS):** Writing and optimizing C/C++ code for hardware synthesis.
- **Vitis HLS and Vivado:** Using AMD Xilinx tools for hardware synthesis and design.
- **Hardware Implementation:** Generating hardware overlays and deploying them on the Pynq-Z2 board.
- **Python Programming:** Interfacing with the hardware accelerator via Jupyter notebooks.
- **Optimization Techniques:** Applying loop unrolling, pipelining, and other transformations to improve performance.
- **Profiling and Analysis:** Measuring and comparing execution times, resource usage, and performance impacts of various optimizations.

### General Overview of the Lab and Results

In this lab, we explored High-Level Synthesis (HLS) to create a hardware accelerator using the Pynq-Z2 board. Our goal was to optimize a C/C++ program for HLS, synthesize it into hardware, and implement it on the Pynq board. We started with an 11-tap FIR filter, optimizing it through various transformations such as loop fission, unrolling, and pipelining.

The lab emphasized the significance of understanding how different optimization techniques impact resource utilization and performance. Initially, we observed that manual code modifications like loop fission and unrolling improved latency but increased resource usage. Automated pragma-based optimizations allowed us to explore different design spaces efficiently.

Key findings included:
- **Manual Unrolling:** Improved latency but increased resource usage.
- **Pragma-based Unrolling:** Reduced resource usage but did not significantly improve latency beyond a certain point.
- **Pipelining:** Helped optimize resource usage and improve performance, but only up to a certain point.

The lab highlighted the importance of careful profiling and balancing optimization techniques to achieve the best performance. Despite various optimizations, the hardware implementation remained slower than the software version, underscoring the complexity of achieving optimal hardware acceleration. This experience reinforced the necessity of understanding low-level optimization impacts and leveraging development tools effectively.
